# 遗传算法

## 参考博客

[【算法】超详细的遗传算法(Genetic Algorithm)解析](https://www.jianshu.com/p/ae5157c26af9)

[遗传算法详解](https://blog.csdn.net/u010712012/article/details/82457655?ops_request_misc=%257B%2522request%255Fid%2522%253A%2522160470797319725225006608%2522%252C%2522scm%2522%253A%252220140713.130102334..%2522%257D&request_id=160470797319725225006608&biz_id=0&utm_medium=distribute.pc_search_result.none-task-blog-2~all~top_click~default-2-82457655.first_rank_ecpm_v3_pc_rank_v2&utm_term=%E9%81%97%E4%BC%A0%E7%AE%97%E6%B3%95&spm=1018.2118.3001.4449)

[了解改良圈算法](https://blog.csdn.net/Fighting_Peter/article/details/104278498?ops_request_misc=%257B%2522request%255Fid%2522%253A%2522160466759619725255525476%2522%252C%2522scm%2522%253A%252220140713.130102334..%2522%257D&request_id=160466759619725255525476&biz_id=0&utm_medium=distribute.pc_search_result.none-task-blog-2~all~top_click~default-1-104278498.first_rank_ecpm_v3_pc_rank_v2&utm_term=%E6%94%B9%E8%89%AF%E5%9C%88%E7%AE%97%E6%B3%95&spm=1018.2118.3001.4449)

[虫口模型](https://wenku.baidu.com/view/eb918036a32d7375a41780b5.html)

[莫烦Python](https://mofanpy.com/tutorials/machine-learning/evolutionary-algorithm/microbial-genetic-algorithm/)

## 生物学术语

基因型(genotype)：性状染色体的内部表现；

表现型(phenotype)：染色体决定的性状的外部表现，或者说，根据基因型形成的个体的外部表现；

进化(evolution)：种群逐渐适应生存环境，品质不断得到改良。生物的进化是以种群的形式进行的。

**适应度(fitness)：度量某个物种对于生存环境的适应程度。**

选择(selection)：以一定的概率从种群中选择若干个个体。一般，选择过程是一种基于适应度的优胜劣汰的过程。

复制(reproduction)：细胞分裂时，遗传物质DNA通过复制而转移到新产生的细胞中，新细胞就继承了旧细胞的基因。

交叉(crossover)：两个染色体的某一相同位置处DNA被切断，前后两串分别交叉组合形成两个新的染色体。也称基因重组或杂交；

变异(mutation)：复制时可能（很小的概率）产生某些复制差错，变异产生新的染色体，表现出新的性状。

**编码(coding)：DNA中遗传信息在一个长链上按一定的模式排列。遗传编码可看作从表现型到基因型的映射。**

**解码(decoding)：基因型到表现型的映射。**

个体（individual）：指染色体带有特征的实体；

种群（population）：个体的集合，该集合内个体数称为种群





## 实现过程

遗传算法的实现过程实际上就像自然界的进化过程那样。首先寻找一种对问题潜在解进行“数字化”编码的方案。（建立表现型和基因型的映射关系）然后用随机数初始化一个种群（那么第一批袋鼠就被随意地分散在山脉上），种群里面的个体就是这些数字化的编码。接下来，通过适当的解码过程之后（得到袋鼠的位置坐标），用适应性函数对每一个基因个体作一次适应度评估（袋鼠爬得越高，越是受我们的喜爱，所以适应度相应越高）。用选择函数按照某种规定择优选择（我们要每隔一段时间，在山上射杀一些所在海拔较低的袋鼠，以保证袋鼠总体数目持平。）。让个体基因变异（让袋鼠随机地跳一跳）。然后产生子代（希望存活下来的袋鼠是多产的，并在那里生儿育女）。遗传算法并不保证你能获得问题的最优解，但是使用遗传算法的最大优点在于你不必去了解和操心如何去“找”最优解。（你不必去指导袋鼠向那边跳，跳多远。）而只要简单的“否定”一些表现不好的个体就行了。（把那些总是爱走下坡路的袋鼠射杀，这就是遗传算法的精粹！）



![20201107193755.jpeg](https://github.com/metaphysicser/picture/blob/master/%20note/Genetic/20201107193755.jpeg?raw=true)

开始循环直至找到满意的解。

1.评估每条染色体所对应个体的适应度。

2.遵照适应度越高，选择概率越大的原则，从种群中选择两个个体作为父方和母方。

3.抽取父母双方的染色体，进行交叉，产生子代。

4.对子代的染色体进行变异。

5.重复2，3，4步骤，直到新种群的产生。

结束循环。

接下来，我们将详细地剖析遗传算法过程的每一个细节。

## 编码方式

明显地，一定长度的二进制编码序列，只能表示一定精度的浮点数。譬如我们要求解精确到六位小数，由于区间长度为2 – (-1) = 3 ,为了保证精度要求，至少把区间[-1,2]分为3 × 106等份。又因为 $2^21<3×10^6<2^22$

所以编码的二进制串至少需要22位。



把一个二进制串（b0,b1,…bn)转化位区间里面对应的实数值通过下面两个步骤。
（1）**将一个二进制串代表的二进制数转化为10进制数：**

![20201107194233.png](https://github.com/metaphysicser/picture/blob/master/%20note/Genetic/20201107194233.png?raw=true)



2）**对应区间内的实数：**

![20201107194301.png](https://github.com/metaphysicser/picture/blob/master/%20note/Genetic/20201107194301.png?raw=true)

![20201107194319.png](https://github.com/metaphysicser/picture/blob/master/%20note/Genetic/20201107194319.png?raw=true)

## 物竞――适应度函数（fitness function）

自然界生物竞争过程往往包含两个方面：生物相互间的搏斗与及生物与客观环境的搏斗过程。但在我们这个实例里面，你可以想象到，袋鼠相互之间是非常友好的，它们并不需要互相搏斗以争取生存的权利。它们的生死存亡更多是取决于你的判断。因为你要衡量哪只袋鼠该杀，哪只袋鼠不该杀，所以你必须制定一个**衡量的标准**。而对于这个问题，这个衡量的标准比较容易制定：袋鼠所在的海拔高度。（因为你单纯地希望袋鼠爬得越高越好。）所以我们直接用袋鼠的海拔高度作为它们的适应性评分。即适应度函数直接返回函数值就行了。

## 2.天择――选择函数（selection)

**下面介绍几种常用的选择算子：**

1. 轮盘赌选择（Roulette Wheel Selection）：是一种回放式随机采样方法。每个个体进入下一代的概率等于它的适应度值与整个种群中个体适应度值和的比例。选择误差较大。

2. 随机竞争选择（Stochastic Tournament）：每次按轮盘赌选择一对个体，然后让这两个个体进行竞争，适应度高的被选中，如此反复，直到选满为止。

3. 最佳保留选择：首先按轮盘赌选择方法执行遗传算法的选择操作，然后将当前群体中适应度最高的个体结构完整地复制到下一代群体中。

4. 无回放随机选择（也叫期望值选择Excepted Value Selection）：根据每个个体在下一代群体中的生存期望来进行随机选择运算。方法如下:

   （1） 计算群体中每个个体在下一代群体中的生存期望数目N。

   （2） 若某一个体被选中参与交叉运算，则它在下一代中的生存期望数目减去0.5，若某一个体未   被选中参与交叉运算，则它在下一代中的生存期望数目减去1.0。

   （3） 随着选择过程的进行，若某一个体的生存期望数目小于0时，则该个体就不再有机会被选中。

5. 确定式选择：按照一种确定的方式来进行选择操作。具体操作过程如下：

   （1） 计算群体中各个个体在下一代群体中的期望生存数目N。

   （2） 用N的整数部分确定各个对应个体在下一代群体中的生存数目。

   （3） 用N的小数部分对个体进行降序排列，顺序取前M个个体加入到下一代群体中。至此可完全确定出下一代群体中Ｍ个个体。

6. 无回放余数随机选择：可确保适应度比平均适应度大的一些个体能够被遗传到下一代群体中，因而选择误差比较小。

7. 均匀排序：对群体中的所有个体按期适应度大小进行排序，基于这个排序来分配各个个体被选中的概率。

8. 最佳保存策略：当前群体中适应度最高的个体不参与交叉运算和变异运算，而是用它来代替掉本代群体中经过交叉、变异等操作后所产生的适应度最低的个体。

9. 随机联赛选择：每次选取几个个体中适应度最高的一个个体遗传到下一代群体中。

10. 排挤选择：新生成的子代将代替或排挤相似的旧父代个体，提高群体的多样性。





下面以轮盘赌选择为例给大家讲解一下：

轮盘赌（Roulette Wheel Selection）选择法。

比如我们有5条染色体，他们所对应的适应度评分分别为：5，7，10，13，15
所以累计总适应度为：

![20201107194509.png](https://github.com/metaphysicser/picture/blob/master/%20note/Genetic/20201107194509.png?raw=true)





所以各个个体被选中的概率分别为：

![20201107194514.png](https://github.com/metaphysicser/picture/blob/master/%20note/Genetic/20201107194514.png?raw=true)

## 基因重组/交叉(recombination/crossover)



适用于二进制编码个体或浮点数编码个体的交叉算子：

1. 单点交叉（One-point Crossover）：指在个体编码串中只随机设置一个交叉点，然后再该点相互交换两个配对个体的部分染色体。

2. 两点交叉与多点交叉：

   (1) 两点交叉（Two-point Crossover）：在个体编码串中随机设置了两个交叉点，然后再进行部分基因交换。

   (2) 多点交叉（Multi-point Crossover）

3. 均匀交叉（也称一致交叉，Uniform Crossover）：两个配对个体的每个基因座上的基因都以相同的交叉概率进行交换，从而形成两个新个体。

4. 算术交叉（Arithmetic Crossover）：由两个个体的线性组合而产生出两个新的个体。该操作对象一般是由浮点数编码表示的个体。



二进制编码的基因交换过程非常类似高中生物中所讲的同源染色体的联会过程――随机把其中几个位于同一位置的编码进行交换，产生新的个体。

![20201107195136.png](https://github.com/metaphysicser/picture/blob/master/%20note/Genetic/20201107195136.png?raw=true)

如果一条基因中含有多个浮点数编码，那么也可以用跟上面类似的方法进行基因交叉，不同的是进行交叉的基本单位不是二进制码，而是浮点数。而如果对于单个浮点数的基因交叉，就有其它不同的重组方式了，比如中间重组：随机产生就能得到介于父代基因编码值和母代基因编码值之间的值作为子代基因编码的值。比如5.5和6交叉，产生5.7，5.6。

## 基因突变(Mutation)

基本位变异（Simple Mutation）：对个体编码串中以变异概率、随机指定的某一位或某几位仅因座上的值做变异运算。

均匀变异（Uniform Mutation）：分别用符合某一范围内均匀分布的随机数，以某一较小的概率来替换个体编码串中各个基因座上的原有基因值。（特别适用于在算法的初级运行阶段）

边界变异（Boundary Mutation）：随机的取基因座上的两个对应边界基因值之一去替代原有基因值。特别适用于最优点位于或接近于可行解的边界时的一类问题。

非均匀变异：对原有的基因值做一随机扰动，以扰动后的结果作为变异后的新基因值。对每个基因座都以相同的概率进行变异运算之后，相当于整个解向量在解空间中作了一次轻微的变动。

高斯近似变异：进行变异操作时用符号均值为Ｐ的平均值，方差为$P^2$的正态分布的一个随机数来替换原有的基因值。



1）二进制编码

基因突变过程：基因突变是染色体的某一个位点上基因的改变。基因突变使一个基因变成它的等位基因，并且通常会引起一定的表现型变化。正如上面所说，二进制编码的遗传操作过程和生物学中的过程非常相类似，基因串上的“ 0”或“ 1”有一定几率变成与之相反的“ 1”或“ 0”。例如下面这串二进制编码：

101101001011001

经过基因突变后，可能变成以下这串新的编码：

001101011011001

（2）浮点型编码

浮点型编码的基因突变过程一般是对原来的浮点数增加或者减少一个小随机数。比如原来的浮点数串如下：

1.2,3.4,5.1, 6.0, 4.5

变异后，可能得到如下的浮点数串：

1.3,3.1,4.9, 6.3, 4.4

当然，这个小随机数也有大小之分，我们一般管它叫“步长”。





## 遗传算法的改进

### 改良圈算法

哈密顿图（哈密尔顿图）（英语：Hamiltonian path，或Traceable path）是一个无向图，由天文学家哈密顿提出，由指定的起点前往指定的终点，途中经过所有其他节点且只经过一次。在图论中是指含有哈密顿回路的图，闭合的哈密顿路径称作哈密顿回路（Hamiltonian cycle），含有图中所有顶点的路径称作哈密顿路径。
从图中的任意一点出发，路途中经过图中每一个结点当且仅当一次，则成为哈密顿回路。（我的理解就是从一点出发经过所有点在回到原始位置画一个圈）
Hamilton圈满足两个条件：①封闭的环②是一个连通图，且图中任意两点可达



首先求得一个Hamilton圈，然后修改圈得到具有较小权的另一个Hamilton圈，直至无法改进则停止

![20201107202643.jpeg](https://github.com/metaphysicser/picture/blob/master/%20note/Genetic/20201107202643.jpeg?raw=true)

用于找到比较好的初始值

## 基因重组和突变的优化

![20201107203002.png](https://github.com/metaphysicser/picture/blob/master/%20note/Genetic/20201107203002.png?raw=true)

很明显这种单点交叉对原来的解改动很小，这可以削弱避免遗传算法在组合优化应用中 产生的寻优抖振问题，可以提高算法收敛精度。



变异也是实现群体多样性的一种手段，是跳出局部最优，全局寻优的重要保证。在 本文具体变异算子设计如下，首先根据给定的变异率(本文选为 0.02)，随机地取两个在 2 到 101 之间的整数，对这两个数对应位置的基因进行变异，具体变异以当前的基因值 为初值利用混沌序列 x(n +1) = 4x(n)(1− x(n)) 进行适当次数的迭代，得到变异后新的基因 值，从而得到新的染色体。



# 进化策略

而传统的 ES DNA 形式分两种, 它有两条 DNA. 一个 DNA 是控制数值的, 第二个 DNA 是控制这个数值的变异强度. 比如一个问题有4个变量. 那一个 DNA 中就有4个位置存放这4个变量的值 (这就是我们要得到的答案值). 第二个 DNA 中就存放4个变量的变动幅度值.

DNA1=`1.23, -0.13, 2.35, 112.5` 可以理解为4个正态分布的4个平均值.

DNA2=`0.1, 2.44, 5.112, 2.144` 可以理解为4个正态分布的4个标准差.

所以这两条 DNA 都需要被 `crossover` 和 `mutate`.

#### 与遗传算法的不同之处：

##### 1.DNA序列采用实数编码，而非0-1二进制码

##### 2.变异时无法进行简单的0-1互换，思考：实数值该怎么变？随机？

变异思路：为DNA序列上的每一个实数值添加变异强度。根据这个变异强度决定DNA序列上的实数值该变成多少

##### 3.编码：

由第2点可知，进化策略在编码时，不仅要有表示解决方案的实数编码链A1，还得有一条表示每个实属值对应的变异强度值组成的链A2（也就是说，遗传给后代的信息有两种）

##### 4.交叉：

两条链都要交叉，即A1与B1交叉形成表示子代解决方案的C1链，A2与B2交叉形成表示C1链对应位置实数值变异强度的C2链（父：A，母：B，子：C）

##### 5.C1链上值的变异方法：

将C1链上的值看作正态分布的均值μ;
将C2链上变异强度值看作标准差σ;
用正态分布产生一个与C1链上选定位置相近的数，进行替换;

##### 6.C2链上值的变异方法：

因为随着不断遗传迭代，种群中个体1号链的值不断逼近最优解，变异的强度也应当不断减小。所以也需要根据需求自定义2号链的变异方法。

##### 7.选择：

将生成的孩子加入父代中，形成一个包含两代DNA的种群U;
对U种群中每个DNA序列的1号链（表示解决方案）进行fitness计算（打分），并根据分值从大到小排列（用U‘表示排列后的混合种群）;
截取U’中的分值高的前n位（n表示一代种群中的个体数目）形成新种群;